<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-geo.v1.min.js"></script>
<body>
<div id="my_dataviz"></div>
</body>
<script>

  var width = 960, 
      height = 1160;

  var projection = d3.geoMercator()
    .scale(4000000)
    .translate([width / 2, height / 2]);

  var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

  let g = d3.json("map.geojson", function(error, NYC_MapInfo) {
    // after loading geojson, use d3.geo.centroid to find out 
    // where you need to center your map
    var center = d3.geo.centroid(NYC_MapInfo);
    projection.center(center);

    // now you can create new path function with 
    // correctly centered projection
    var path = d3.geo.path().projection(projection);

    // and finally draw the actual polygons
    svg.selectAll("path")
      .data(NYC_MapInfo.features)
      .enter()
      .append("path")
      .attr("d", path);
  });
	g.then(function(result){
    var center = d3.geoCentroid(result);
	console.log(center)
    projection.center(center);

    // now you can create new path function with 
    // correctly centered projection
    var path = d3.geoPath().projection(projection);

    // and finally draw the actual polygons
    svg.selectAll("path")
      .data(result.features)
      .enter()
      .append("path")
      .attr("d", path)
      .attr("id", function(d) { return  d.properties['name'];})
      .style("fill", function(d){ if(d.properties['name'] === 'Worcester Polytechnic Institute'){ return "none";} else {return "#00001f4f";}})
    .style("stroke", function(d){ if(d.properties['name'] === 'Worcester Polytechnic Institute'){ return "red" ;} else {return "grey";}}) 
d3.csv("responses.csv").then((data) => {
    var myColor = d3.scaleLinear()
        .range(["white", "steelblue"])
        .domain([1, 5])
    let times = Object.keys(data[0])
    times = times.filter((a) => a !== "Timestamp" && !a.includes("Other"))
    times.forEach((d, i) => {
        times[i] = d 
   })
    let locationAndTimeMap = {}
    for (let i = 0; i < data.length; i++) {
        const currentResponse = data[i]
        for (key in currentResponse) {
            if (key.includes("Other") || key === "Timestamp") {
                continue
            }
            const currentBuilding = currentResponse[key]
            if (currentBuilding in locationAndTimeMap) {
                if (key in locationAndTimeMap[currentBuilding]) {
                    locationAndTimeMap[currentBuilding][key] = locationAndTimeMap[currentBuilding][key] + 1
                } else {
                    locationAndTimeMap[currentBuilding][key] = 1
                }
            } else {
                const toMake = {}
                toMake[key] = 1
                locationAndTimeMap[currentBuilding] = toMake
            }
        }
    }
	buildings_info = []
	for(key in locationAndTimeMap){
		time_quant_pair = []
		for(v in times){
			if(locationAndTimeMap[key][times[v]] > 0){
			time_quant_pair.push([v, locationAndTimeMap[key][times[v]]]);
		} else {
			time_quant_pair.push([v,0])
		}
		}
		buildings_info.push([key, time_quant_pair])
	}
	console.log(buildings_info)
	function updateTheMap(buildings_info,i){
	for(building in buildings_info){
		try{
			let sel = d3.selectAll("[id='" + buildings_info[building][0] + "']")
			sel.style("fill",  myColor(buildings_info[building][1][i][1]))
		} catch {
		}
	}
	}
 const duration = 4000;
   let i = 0;
   timer = d3.timer((elapsed) => {
    i = Math.floor(elapsed * 12 / duration)
    updateTheMap(buildings_info, i)
    if (elapsed > duration ) {
      timer.stop();
    }
  });
	

	})


})


</script>
